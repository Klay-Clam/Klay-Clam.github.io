<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Klay-Clam"><title>[转载]javascript中的作用域和闭包问题 · Klay-Clam's Blog</title><meta name="description" content="前言学习了javascript已经很久了，关于这个语言中的这两个特性也是早已耳熟能详，但是在实际的使用的过程中或者是遇到相关的问题的时候，还是不能很好的解决。因此我觉得很有必要深入的学习并且记录这个问题，以便在今后的学习和使用的过程中回顾。 
正文1. 全局作用域
浏览器环境
  所有浏览器都支持 "><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Typography</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">活版印字</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://github.com/Klay-Clam" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2018&nbsp;<a target="_blank" href="http://yoursite.com" rel="noopener noreferrer">Klay-Clam</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>[转载]javascript中的作用域和闭包问题</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2017-10-18</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/javascript/" title="javascript" class="a-tag">javascript</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/闭包/" title="闭包" class="a-tag">闭包</a><span>&nbsp;</span><a href="/tags/作用域/" title="作用域" class="a-tag">作用域</a><span>&nbsp;</span></span></p><p class="post-abstract"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习了javascript已经很久了，关于这个语言中的这两个特性也是早已耳熟能详，但是在实际的使用的过程中或者是遇到相关的问题的时候，还是不能很好的解决。<br>因此我觉得很有必要深入的学习并且记录这个问题，以便在今后的学习和使用的过程中回顾。<br><a id="more"></a> </p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1. 全局作用域"></a>1. 全局作用域</h3><ul>
<li><p>浏览器环境</p>
<p>  所有浏览器都支持 <code>window</code> 对象，它表示浏览器窗口，JavaScript 全局对象、函数以及变量均自动成为 <code>window</code> 对象的成员。<br><br>  所以，全局变量是 window 对象的属性，全局函数是 window 对象的方法，甚至 HTML DOM 的 <code>document</code> 也是 window 对象的属性之一。<br><br>  全局变量是JavaScript里生命周期（一个变量多长时间内保持一定的值）最长的变量，其将跨越整个程序，可以被程序中的任何函数方法访问。<br><br>  在全局下声明的变量都会在window对象下，都在全局作用域中，我们可以通过window对象访问，也可以直接访问。</p>
</li>
<li><p>Node环境</p>
<p>  全局对象是<code>global</code>对象，与<code>window</code>类似，在全局下声明的所有的变量都在<code>global</code>对象之下，都在全局作用域中，可以通过<code>glocal</code>访问，也可以通过变量名访问。</p>
  <figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">name</span> = <span class="string">'clam'</span>;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">name</span>); <span class="comment">// clam</span></span><br><span class="line"><span class="comment">// 浏览器环境</span></span><br><span class="line">console.<span class="built_in">log</span>(window.<span class="built_in">name</span>); <span class="comment">// clam</span></span><br><span class="line"><span class="comment">// Node环境</span></span><br><span class="line">console.<span class="built_in">log</span>(global.<span class="built_in">name</span>); <span class="comment">// clam</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明方式产生全局变量</p>
<p>  在js的任何位置，声明变量的时候没有使用<code>var</code>关键字，这个变量就是全局变量。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum = a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 相当于以下代码</span></span><br><span class="line"><span class="comment"> * 这里涉及到变量提升的问题，我会另外写一篇来专门说明这个问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum = a+b;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>) ; <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
<p>全局变量存在于整个函数的生命周期中，然而其在全局范围内很容易被篡改，我们在使用全局变量时一定要小心，尽量不要使用全局变量。在函数内部声明变量没有使用var也会产生全局变量，会为我们造成一些混乱，比如变量覆盖等。所以，我们在声明变量的任何时候最好都要带上var。</p>
<p><strong>全局变量存在于程序的整个生命周期，但并不是通过其引用我们一定可以访问到全局变量。</strong></p>
<h3 id="2-词法作用域"><a href="#2-词法作用域" class="headerlink" title="2. 词法作用域"></a>2. 词法作用域</h3></li>
</ul>
<p><strong>词法作用域</strong>：函数在定义它们的作用域里运行，而不是在执行它们的作用域里运行。也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。with和eval除外，所以只能说JS的作用域机制非常接近词法作用域（Lexical scope）。词法作用域也可以理解为一个变量的可见性，及其文本表述的模拟值。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"global"</span>;</span><br><span class="line"></span><br><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"clam"</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="function"><span class="title">fun</span><span class="params">()</span></span>); <span class="comment">// 输出:clam</span></span><br><span class="line">console.log(name); <span class="comment">// 输出:global</span></span><br></pre></td></tr></table></figure></p>
<p>在通常情况下，变量的查询从最近接的绑定上下文开始，向外部逐渐扩展，直到查询到第一个绑定，一旦完成查找就结束搜索。就像上例，先查找离它最近的name=”clam”，查询完成后就结束了，将第一个获取的值作为变量的值。</p>
<h3 id="3-动态作用域"><a href="#3-动态作用域" class="headerlink" title="3. 动态作用域"></a>3. 动态作用域</h3><p>动态作用域与词法作用域相对而言的，不同于词法作用域在定义时确定，<strong>动态作用域在执行时确定，其生存周期到代码片段执行为止</strong>。动态变量存在于动态作用域中，任何给定的绑定的值，在确定调用其函数之前，都是不可知的。</p>
<p>在代码执行时，对应的作用域链常常是保持静态的。然而当遇到<code>with</code>语句、<code>call</code>方法、<code>apply</code>方法和<code>try-catch</code>中的<code>catch</code>时，会改变作用域链的。以<code>with</code>为例，在遇到<code>with</code>语句时，会将传入的对象属性作为局部变量来显示，使其便于访问，也就是说把一个新的对象添加到了作用域链的顶端，这样必然影响对局部标志符的解析。<strong>当<code>with</code>语句执行完毕后，会把作用域链恢复到原始状态</strong>。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo</span></span><br><span class="line">var <span class="built_in">name</span> = <span class="string">"global"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with之前</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">name</span>); <span class="comment">// 输出:global</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(&#123;<span class="built_in">name</span>:<span class="string">"jeri"</span>&#125;)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">name</span>); <span class="comment">// 输出:jeri</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with之后，作用域链恢复</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">name</span>); <span class="comment">// 输出:global</span></span><br></pre></td></tr></table></figure>
<p>在作用域链中有动态作用域时，this引用也会变得更加复杂，不再指向第一次创建时的上下文，而是由调用者确定。比如在使用apply或call方法时，传入它们的第一个参数就是被引用的对象。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">globalThis</span>() &#123;</span><br><span class="line">    <span class="selector-tag">console</span><span class="selector-class">.log</span>(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">globalThis</span>(); <span class="comment">// 输出:Window &#123;document: document,external: Object…&#125;</span></span><br><span class="line"><span class="selector-tag">globalThis</span><span class="selector-class">.call</span>(&#123;<span class="attribute">name</span>:<span class="string">"clam"</span>&#125;); <span class="comment">// 输出:Object &#123;name: "clam"&#125;</span></span><br><span class="line"><span class="selector-tag">globalThis</span><span class="selector-class">.apply</span>(&#123;<span class="attribute">name</span>:<span class="string">"clam"</span>&#125;,<span class="selector-attr">[]</span>); <span class="comment">// 输出:Object &#123;name: "clam"&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>因为this引用是动态作用域，所以在编程过程中一定要注意this引用的变化，及时跟踪this的变动。</p>
<h3 id="4-函数作用域"><a href="#4-函数作用域" class="headerlink" title="4 .函数作用域"></a>4 .函数作用域</h3><p>函数作用域，顾名思义就是在定义函数时候产生的作用域，这个作用域也可以称为<strong>局部作用域</strong>。和全局作用域相反，函数作用域一般只在函数的代码片段内可访问到，外部不能进行变量访问。在函数内部定义的变量存在于函数作用域中，其生命周期随着函数的执行结束而结束。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"global"</span>;</span><br><span class="line"></span><br><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"clam"</span>;</span><br><span class="line">    console.log(name); <span class="comment">// 输出:jeri</span></span><br><span class="line"></span><br><span class="line">    with (&#123;name:<span class="string">"with"</span>&#125;) &#123;</span><br><span class="line">        console.log(name); <span class="comment">// 输出:with</span></span><br><span class="line">    &#125;</span><br><span class="line">    console.log(name); <span class="comment">// 输出:clam</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能访问函数作用域</span></span><br><span class="line">console.log(name); <span class="comment">// 输出:global</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-没有块级作用域"><a href="#5-没有块级作用域" class="headerlink" title="5. 没有块级作用域"></a>5. 没有块级作用域</h3><p>不同于其他编程语言，在JavaScript里并没有块级作用域，也就是说在for、if、while等语句内部的声明的变量与在外部声明是一样的，在这些语句外部也可以访问和修改这些变量的值.<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">"clam"</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    console.log(name); <span class="comment">// 输出:clam</span></span><br><span class="line">    name = <span class="string">"klay"</span>;</span><br><span class="line">    console.log(name); <span class="comment">// 输出:klay</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-作用域链"><a href="#6-作用域链" class="headerlink" title="6. 作用域链"></a>6. 作用域链</h3><p>JavaScript里一切皆为对象，包括函数。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是作用域，包含了函数被创建的作用域中对象的集合，称为函数的作用域链，它<strong>用来保证对执行环境有权访问的变量和函数的有序访问</strong>。</p>
<p>当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。<strong>在全局作用域中创建的函数，其作用域链会自动成为全局作用域中的一员。而当函数执行时，其活动对象就会成为作用域链中的第一个对象</strong>（活动对象：对象包含了函数的所有局部变量、命名参数、参数集合以及this）。在程序执行时，Javascript引擎会通过搜索上下文的作用域链来解析诸如变量和函数名这样的标识符。其会从作用域链的最里面开始检索，按照由内到外的顺序，直到完成查找，一旦完成查找就结束搜索。<strong>如果没有查询到标识符声明，则报错</strong>。当函数执行结束，运行期上下文被销毁，活动对象也随之销毁。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    console.log(name); <span class="comment">// output:global</span></span><br><span class="line">    name = <span class="string">"change"</span>;</span><br><span class="line">    <span class="comment">// 函数内部可以修改全局变量</span></span><br><span class="line">    console.log(name); <span class="comment">// output:change</span></span><br><span class="line">    <span class="comment">// 先查询活动对象</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="string">"18"</span>;</span><br><span class="line">    console.log(age); <span class="comment">// output:18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数执行完毕，执行环境销毁</span></span><br><span class="line">console.log(age); <span class="comment">// output:Uncaught ReferenceError: age is not defined</span></span><br></pre></td></tr></table></figure></p>
<h3 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7. 闭包"></a>7. 闭包</h3><p>闭包是JavaScript的一大谜团，关于这个问题有很多文章进行讲述，然而依然有相当数量的程序员对这个概念理解不透彻。闭包的官方定义为：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p>一句话概括就是：<em>闭包就是一个函数，捕获作用域内的外部绑定</em>。这些绑定是为之后使用而被绑定，即使作用域已经销毁。</p>
<ul>
<li>自由变量<br><strong>自由变量与闭包的关系是，自由变量闭合于闭包的创建</strong>。闭包背后的逻辑是，如果一个函数内部有其他函数，那么这些内部函数可以访问在这个外部函数中声明的变量（这些变量就称之为自由变量）。然而，这些变量可以被内部函数捕获，从高阶函数（返回另一个函数的函数称为高阶函数）中return语句实现“越狱”，以供以后使用。内部函数在没有任何局部声明之前（既不是被传入，也不是局部声明）使用的变量就是被捕获的变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">captured</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">free</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = free + captured;</span><br><span class="line">        <span class="built_in">console</span>.log(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">add10(<span class="number">2</span>); <span class="comment">// 输出:12</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从上例可知，外部函数中的变量captured被执行加法的返回函数捕获，内部函数从未声明过captured变量，却可以引用它。</p>
<p>如果我们再创建一个加法器将捕获到同名变量captured，但有不同的值，因为这个加法器是在调用makeAdder之后被创建：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var add<span class="number">16</span> = makeAdder<span class="comment">(16)</span>;</span><br><span class="line"> </span><br><span class="line">add<span class="number">16</span><span class="comment">(18)</span>; <span class="comment">// 输出:34</span></span><br><span class="line"> </span><br><span class="line">add<span class="number">10</span><span class="comment">(10)</span>; <span class="comment">// 输出:20</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>变量遮蔽<br>在JavaScript中，当变量在一定作用域内声明，然后在另一个同名变量在一个较低的作用域声明，会发生变量的遮蔽。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"clam"</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"klay"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">glbShadow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"fun"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// 输出:fun</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glbShadow();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出:tom</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当在一个变量同一作用域内声明了多次时，最后一次声明会生效，会遮蔽以前的声明。</p>
<p>变量声明的遮蔽很好理解，然而函数参数的遮蔽就略显复杂。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shadowed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = [<span class="string">"Value is"</span>,shadowed].join(<span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">argShadow(<span class="number">108</span>); <span class="comment">// output:Value is 108</span></span><br><span class="line"></span><br><span class="line">argShadow(); <span class="comment">// output:Value is</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>argShadow</code>的参数<code>shadowed</code>覆盖了全局作用域内的同名变量。即使没有传递任何参数，仍然绑定的是<code>shadowed</code>，并没有访问到全局变量<code>shadowed = 0</code>。</p>
<p>任何情况下，离得最近的变量绑定优先级最高。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shadowed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> shadowed = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">var</span> str = [<span class="string">"Value is"</span>,shadowed].join(<span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">varShadow(<span class="number">108</span>); <span class="comment">// output:Value is 123</span></span><br><span class="line"></span><br><span class="line">varShadow(); <span class="comment">// output:Value is 123</span></span><br></pre></td></tr></table></figure></p>
<p><code>varShadow(108)</code>打印出来的并不是<code>108</code>而是<code>123</code>，即使没有参数传入也是打印的<code>123</code>，先访问离得最近的变量绑定。</p>
<p><strong>遮蔽变量同样发生在闭包内部</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">captureShadow</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(shadowed); <span class="comment">// output:108</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">shadowed</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(shadowed); <span class="comment">// output:2</span></span><br><span class="line">        <span class="keyword">var</span> ret = shadowed + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(ret); <span class="comment">// output:3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closureShadow = captureShadow(<span class="number">108</span>);</span><br><span class="line"></span><br><span class="line">closureShadow(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在编写JavaScript代码时，因为变量遮蔽会使很多变量绑定超出我们的控制，我们应尽量避免变量遮蔽，一定要注意变量命名。</p>
</blockquote>
<ul>
<li>典型的误区<blockquote>
<p>首先看下面的代码:</p>
</blockquote>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var test = function() &#123;</span><br><span class="line"><span class="code">    var ret = [];</span></span><br><span class="line"></span><br><span class="line"><span class="code">    for(var i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="code">        ret[i] = function() &#123;</span></span><br><span class="line"><span class="code">            return i;  </span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="code">    return ret;</span></span><br><span class="line">&#125;;</span><br><span class="line">var test0 = test()[<span class="string">0</span>](<span class="link"></span>);</span><br><span class="line">console.log(test0); // 输出：5</span><br><span class="line"></span><br><span class="line">var test1 = test()[<span class="string">1</span>](<span class="link"></span>);</span><br><span class="line">console.log(test1); //输出：5</span><br></pre></td></tr></table></figure>
<p>从上面的例子可知，<code>test</code>这个函数执行之后返回一个函数数组，表面上看数组内的每个函数都应该返回自己的索引值，然而并不是如此。当外部函数执行完毕后，外部函数虽然其执行环境已经销毁，但闭包依然保留着对其中变量绑定的引用，仍然驻留在内存之中。当外部函数执行完毕之后，才会执行内部函数，而这时内部函数捕获的变量绑定已经是外部函数执行之后的最终变量值了，所以这些函数都引用的是同一个变量<code>i=5</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更加优雅的描述方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);  </span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔1秒输出一个5</span></span><br></pre></td></tr></table></figure></p>
<p>按照我们的推断，上例应该输出<code>1,2,3,4,5</code>。然而，事实上输出的是连续5个<code>5</code>。为什么出现这种诡异的状况呢？其本质上还是由闭包特性造成的，闭包可以捕获外部作用域的变量绑定。</p>
<p>上面这个函数片段在执行时，其内部函数和外部函数并不是同步执行的，因为当调用<code>setTimeout</code>时会有一个延时事件排入队列，等所有同步代码执行完毕后，再依次执行队列中的延时事件，而这个时候<code>i</code>已经 是<code>5</code>了。</p>
<p>那怎么解决这个问题呢？我们是不是可以在每个循环执行时，给内部函数传进一个变量的拷贝，使其在每次创建闭包时，都捕获一个变量绑定。因为我们每次传参不同，那么每次捕获的变量绑定也是不同的，也就避免了最后输出5个5的状况。实例如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">var</span> i = <span class="number">0</span><span class="comment">; i &lt; 5; i++) &#123;</span></span><br><span class="line"></span><br><span class="line">    (<span class="name">function</span>(<span class="name">j</span>) &#123;</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="name">function</span>() &#123;</span><br><span class="line">            console.log(<span class="name">j</span>)<span class="comment">;  </span></span><br><span class="line">        &#125;, <span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line">    &#125;)(<span class="name">i</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出：<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>闭包具有非常强大的功能，函数内部可以引用外部的参数和变量，但其参数和变量不会被垃圾回收机制回，常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。但，闭包也是javascript语言的一大特点，主要应用闭包场合为：<strong>设计私有的方法和变量</strong>。 </p>
<ul>
<li>模拟私有变量<br>从上文的叙述我们知道，变量的捕获发生在创建闭包的时候，那么我们可以把闭包捕获到的变量作为私有变量。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closureDemo = (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">PRIVATE</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        inc:<span class="function"><span class="keyword">function</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">PRIVATE</span> += n;</span><br><span class="line">        &#125;,</span><br><span class="line">        dec:<span class="function"><span class="keyword">function</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">PRIVATE</span> -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testInc = closureDemo.inc(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//console.log(testInc);</span></span><br><span class="line"><span class="comment">// 输出：10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testDec = closureDemo.dec(<span class="number">7</span>);</span><br><span class="line"><span class="comment">//console.log(testDec);</span></span><br><span class="line"><span class="comment">// 输出：3</span></span><br><span class="line"></span><br><span class="line">closureDemo.div = <span class="function"><span class="keyword">function</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">PRIVATE</span> / n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testDiv = closureDemo.div(<span class="number">3</span>);</span><br><span class="line">console.log(testDiv);</span><br><span class="line"><span class="comment">//输出：Uncaught ReferenceError: PRIVATE is not defined</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>自执行函数<code>closureDemo</code>执行完毕之后，自执行函数作用域和<code>PRIVATE</code>随之销毁，但<code>PRIVATE</code>仍滞留在内存中，也就是加入到<code>closureDemo.inc</code>和<code>closureDemo.dec</code>的作用域链中，闭包也就完成了变量的捕获。但之后新加入的<code>closureDemo.div</code>并不能在作用域中继续寻找到<code>PRIVATE</code>了。因为，函数只有被调用时才会执行函数里面的代码，变量的捕获也只发生在创建闭包时，所以之后新加入的<code>div</code>方法并不能捕获<code>PRIVATE</code>。</p>
<ul>
<li>创建特权方法<br>通过闭包我们可以创建私有作用域，那么也就可以创建私有变量和私有函数。创建私有函数的方式和声明私有变量方法一致，只要在函数内部声明函数就可以了。当然，既然可以模拟私有变量和私有函数，我们也可以利用闭包这个特性，创建特权方法。<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    MyObj = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有/特权方法</span></span><br><span class="line">    MyObj.prototype.publicMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        privateVar ++;</span><br><span class="line">        <span class="keyword">return</span> privateFun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面这个实例创建了一个私有作用域，并封装了一个构造函数和对应的方法。需要注意的是在上面的实例中，在声明<code>MyObj</code>这个函数时，使用的是不带<code>var</code>的函数表达式，我们希望产生的是一个全局函数而不是局部的，不然我们依然在外部无法访问。所以，<code>MyObj</code>就成为了一个全局变量，能够在外部进行访问，我们在原型上定义的方法<code>publicMethod</code>也就可以使用，通过这个方法我们也就可以访问私有函数和私有变量了。</p>
<p>总的来说，因为闭包奇特的特性，可以通过它实现一些强大的功能。但，我们在日常编程中，也要正确的使用闭包，要时刻注意回收不用的变量，避免内存泄露。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>感谢原文作者，并且附上原文链接：<a href="http://www.cnblogs.com/syfwhu/p/4839562.html" target="_blank" rel="noopener">JavaScript之作用域与闭包详解</a></p>
</blockquote>
<p>花费了数小时来研读这篇分享，对javascript中的作用域和闭包的问题有了比较深刻的认识和学习。在今后的编码过程中，希望可以将今天学到的东西及时应用，反复的巩固。</p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=http://yoursite.com/2017/10/18/转载-javascript中的作用域和闭包问题/%20Klay-Clam's Blog%20[转载]javascript中的作用域和闭包问题" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2017/10/22/awesome-idea/" title="AWESOME IDEA 和 最近的一些思考"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: AWESOME IDEA 和 最近的一些思考</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2017/10/16/callapplybind/" title="JavaScript 中的call(),apply()和bind()">Next post: JavaScript 中的call(),apply()和bind()&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2018&nbsp;<a target="_blank" href="http://yoursite.com" rel="noopener noreferrer">Klay-Clam</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>